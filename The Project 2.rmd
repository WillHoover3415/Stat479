---
title: "The project 2"
author: "Roy Son"
date: "2025-11-02"
output: html_document
---
### To estimate and evaluate the Bradley-Terry model, we first load two key packages.BradleyTerry2 package provides the estimation functions for fitting Bradley-Terry models, including the ability to incorporate covarites such as home-field advanage. Tidyverse is included for data wrangling and visualization.
```{r setup, include = FALSE}
library(BradleyTerry2)
library(tidyverse)
```



### Now we imported the excel file that contained 2024 MLB game dataset. It corresponds to a individual MLB game in the 2024 regular season, including the home team, away team, outcome, and the identity of the starting pitchers.
```{r}
season_2024 = read_csv("games_with_pitchers.csv")

season_2024 = season_2024 %>%
  arrange(Date, row_number())
```



### Now we prepare pairwise comparison for Bradley-Terry Model. In this step, we transform the raw game data into the specific columns needed for a Bradley-Terry model. The model requires us to identify the two competitors in each pariod comparison(home vs away), along with an indicator of who won. We convert both the home team and away team names to factor variables, as BTm() expects categorical team identifiers. We then record the binary outcome of each matchup(1 = win, 0 = loss) for the home team and away team. Finally, we label the home team as playing at home(1) and the away team as playing not at home(0). They will alow the model to estiamte a home field advantage in additon to each team's strength. 
```{r}
Bradley_Terry = season_2024 %>%
  transmute(
    home.team = factor(Home_Tm),
    away.team = factor(Away_Tm),
    home.win = as.integer(Home_Winner),
    away.win = as.integer(Away_Winner),
    at.home_home = 1,
    at.home_away = 0,
    era_difference_raw = Home_Pitcher_ERA - Away_Pitcher_ERA
  )%>% 
  filter(!is.na(era_difference_raw)) %>%
  mutate(era_difference = era_difference_raw - mean(era_difference_raw, na.rm=TRUE))
```


### The BTm() function does not accept a single dta table. Instead, it expects a very specific strucutre: the outcome columns are separate, and each competitors are represneted by a nested data frame that incldes metadata. In this case, each competitotr column includes two pieces of information: the team identity(team) and whether the team was playing at home(at.home). We therefore construct a new temporary data frame called data_frame that allows this strucutre. First it stores the observed binary outcomes(home wins vs away wins). Then we add two columns(home.team and away.team) that each contain their own two column data frame. We did this because it is required input format for BradleyTerry2's BTm() function. 
```{r}
data_frame = data.frame(
  home.win = Bradley_Terry$home.win,
  away.win = Bradley_Terry$away.win
)

data_frame$home.team = data.frame(
  team = Bradley_Terry$home.team,
  at.home = 1,
  era = + Bradley_Terry$era_difference/2
)

data_frame$away.team = data.frame(
  team = Bradley_Terry$away.team,
  at.home = 0,
  era = - Bradley_Terry$era_difference/2
)
```


### Now we estimate the Bradley-Terry model using the structured data we created. The variable reference_team specifies which team's ability parameter will be set to zero to anchor the model. Because Bradley-Terry parameters are only identifiable up to an additive constant, one team must be chose as the basline reference. Here, we simply select the first level of the factor vairable and set that as the reference. Finally, the BTm() we talked earlier kicks in. BTm() is called to fit the model. The outcome argument gives the two column matrix of win indicators. player 1 and player 2 map to the nested columns created earlier, describing identity and at home status for each competitor. The model formula ~ team + at.home tells the estimator to estimate one "ability" parameter per team, plus an additonal parameter capturing systematic home field advatnage. Finally, we pass data_frame, which matches the internal format expected by BTm(). summary(fit) shows the results of the model, including the estiamted coefficients for each team and the home advantage term, along with standard errors and significance tests. 

```{r}
reference_team = levels(Bradley_Terry$home.team)[4]

fit = BTm(
  outcome = cbind(home.win, away.win),
  player1 = home.team,
  player2 = away.team,
  formula = ~ team + at.home + era,
  refcat = reference_team,
  id = "team",
  data = data_frame
)

summary(fit)
```

###After fitting the Bradley-Terry model, we extract the estimated team strength parameters. The BTabilities() function converts the fitted model into a table of each team's ability estimate and associated standard error. We convert this into a normal data frame, promote the row names into a column named "Team", and then sort the table so that the strongest teams(highest estimated ability parameters) appear first. Rankings represent the model's ordering of overall team strength based soley on win/loss results and home field adjustments. We also extract the estimated coefficient for the at.home covariate, which represents the systematic advatnage associated with playing at home. This parameter is on the log odds scale. A positive value means that a home team would have higher expected probability of winning after adjusting for the difference in the ability levels. By calling, unname(), we store this coefficent as a single numeric value that can later be directly inserted into probability calculations. 
```{r}
team_abilities = BradleyTerry2::BTabilities(fit) %>%
  as.data.frame()%>%
  rownames_to_column("Team") %>%
  arrange(desc(ability))
team_abilities 

coefficient = coef(fit)

home_adventage = unname(coefficient["at.home"])
```


### Then, we conver the raw ability estimates into a rank table that is easier for us to interpret. First, we compute an explicit numerical ranking, ordering teams from strongest to weaksest, based on their estimated ability parameter. We rank 
```{r}
rank = team_abilities %>%
  mutate(
    Rank = rank(-ability, ties.method = "min"),
    low = ability - 1.96 * `s.e.`,
    high = ability + 1.96 * `s.e.`,
  ) %>%
  select(Rank, Team, ability, low, high,`s.e.`)
```



```{r}
home_ability = team_abilities %>%
  select(Team, ability) %>%
  rename(home.team = Team, ability_home = ability)

away_ability = team_abilities %>%
  select(Team, ability) %>%
  rename(away.team = Team, ability_away = ability)

evaluation = Bradley_Terry  %>%
  mutate(row_id = row_number()) %>%
  left_join(home_ability, by = "home.team") %>%
  left_join(away_ability, by = "away.team") %>%
  mutate(
    linear_predictor = (ability_home - ability_away) + home_adventage * 1,
    probability_home_team = 1/ (1 + exp(-linear_predictor)),
    y = home.win
  )
```



```{r}
brier = mean((evaluation$probability_home_team - evaluation$y)^2)

log_loss = -mean(
  evaluation$y * log(pmax(pmin(evaluation$probability_home_team, 1 - 1e-12),1e-12))
)

brier 
log_loss
```




```{r}
expected_wins_home = evaluation %>%
  group_by(home.team) %>%
  summarize(expected_home_wins = sum(probability_home_team), .groups = "drop")

expected_wins_away = evaluation %>%
  mutate(paway = 1 - probability_home_team) %>%
  group_by(away.team) %>%
  summarize(expected_away_wins = sum(paway),.groups = "drop")

expected_wins = expected_wins_home %>%
  full_join(expected_wins_away, by = c("home.team" = "away.team")) %>%
  transmute(
    Team = home.team,
    Expected_wins = coalesce(expected_home_wins, 0) + coalesce(expected_away_wins,0)
  )


actual_wins = season_2024 %>%
  mutate(Winner = as.character(Winner)) %>%
  count(Winner, name = "Actual_Wins") %>%
  rename(Team = Winner)

expected_vs_actual_wins = expected_wins %>%
  full_join(actual_wins, by = "Team") %>%
  replace_na(list(Expected_wins=0, Actual_Wins = 0))%>%
  mutate(
    Expected_Wins = round(Expected_wins,0),
    Actual_Wins = round(Actual_Wins,0)
  )%>%
  select(-Expected_wins)%>%
  arrange(desc(Expected_Wins))%>%
  print(n=30)
```

```{r}
ggplot(rank, aes(x = reorder(Team, ability), y = ability))+
  geom_point()+
  geom_errorbar(aes(ymin = low, ymax = high), width = 0.2)+
  coord_flip()+
  labs(
    title = "Bradley-Terry Team Abilities",
    x = "Team",
    y = "Ability"
  )+theme_minimal()
```


`
```{r}
mlb_salary = read_csv("mlb_salary_data.csv") 

mlb_salary = mlb_salary %>%
  filter(Year == "2024")

season_2024 = season_2024 %>%
  left_join(mlb_salary, by = c("Home_Pitcher" = "Name"))%>%
  rename(Home_Pitcher_Salary = Salary) %>%
  left_join(mlb_salary, by = c("Away_Pitcher" = "Name"))%>%
  rename(Away_Pitcher_Salary = Salary)

season_2024 = season_2024 %>%
  mutate(
    Home_Pitcher_Salary = as.numeric(gsub("[\\$,]", "", Home_Pitcher_Salary)),
    Away_Pitcher_Salary = as.numeric(gsub("[\\$,]", "", Away_Pitcher_Salary))
  )

season_2024 = season_2024 %>%
  mutate(salary_difference = Home_Pitcher_Salary - Away_Pitcher_Salary)%>%
  mutate(salary_difference = salary_difference - mean(salary_difference, na.rm = TRUE))

data_frame$home.team$salary = + season_2024$salary_difference/2
data_frame$away.team$salary = - season_2024$salary_difference/2

fit_2 = BTm(
  outcome = cbind(home.win, away.win),
  player1 = home.team,
  player2 = away.team,
  formula = ~ team + at.home + era + salary,
  id = "team",
  refcat = reference_team,
  data = data_frame
)

summary(fit_2)
```

