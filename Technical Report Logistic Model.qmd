---
title: "The Technical Report for the Logistic Model"
author: "JP Daliere"
format: html
editor: visual
---

**Motivation behind using a Logistic Regression Model:**

An issue with the naive binning and average model is that it can make estimates on small samples of data. This often occurs when the model uses continuous variables.

In this scenario, a logistic regression model is a good alternative. This is because logistic regression models are fit to the data and can make reasonable estimates for the relationships between continuous variables and the response variable.

**Logistic Model Expression:**

(log-odds of Y) = ð›½0 + ð›½1X1 + â€¦ + ð›½pXp

-   Binary Outcome Y (Probability of a shot being made)Â 

-   Variables X1, â€¦ , XP

**Our Logistic Model:**

Our logistic model is modeling the probability that a shot results in a made basket. It is accounting for several continuous and categorical variables. One nice aspect of the logistic regression model which we laid out above is that it can account for continuous variables. This allows us to add some very important predictors into our model including location (x,y coordinate of the shot) and time (the time remaining in the quarter and the game). We expect intuitively that accounting for these variables will make our model more accurate. Let's see if this is the case!

For reference, these are the 13 variables used in our model:

1.  Location X (X-coordinate of the shot); continuous
2.  Location Y (Y-coordinate of the shot); continuous
3.  Shot Distance (ft away from the basket); continuous
4.  Action Type (specific type of shot); categorical
5.  Shot Zone Basic (zone of the court where a shot was taken); categorical
6.  Shot Zone Area (area of the court where a shot was taken); categorical
7.  Shot Zone Range (ft range away from the basket); categorical
8.  Shot Type (2-pointer or 3-pointer); categorical
9.  Period (quarter of the game (1-4)); categorical
10. Minutes Remaining (minutes on the clock); continuous
11. Seconds Remaining (seconds on the clock); continuous
12. Quarter Time Left (time remaining in the quarter (in seconds)); continuous
13. Game Time Left (time (in seconds) remaining in the game); continuous

**Data Tidying & Preparation:**

First, we clean the data. We derive three new variables: quarter_time_left (seconds remaining in the quarter), game_time_left (seconds remaining in the game), and possible points (the number of points a shot is worth). We also convert all of our variables to the appropriate type. This prepares our data for analysis.

```{r}
library(tidyverse)
library("hoopR")
library("dplyr")
library(tictoc)
library(devtools)
library(pacman)
```

```{r}

shots_2025 = shots_2025 %>% 
  mutate(TEAM_NAME = case_when(
  TEAM_NAME == "New York Knicks" ~ "NYK",
  TEAM_NAME == "Houston Rockets" ~ "HOU",
  TEAM_NAME == "Miami Heat" ~ "MIA",
  TEAM_NAME == "Toronto Raptors" ~ "TOR",
  TEAM_NAME == "Memphis Grizzlies" ~ "MEM",
  TEAM_NAME == "Denver Nuggets" ~ "DEN",
  TEAM_NAME == "Minnesota Timberwolves" ~ "MIN",
  TEAM_NAME == "Phoenix Suns" ~ "PHX",
  TEAM_NAME == "Cleveland Cavaliers" ~ "CLE",
  TEAM_NAME == "New Orleans Pelicans" ~ "NOP",
  TEAM_NAME == "Golden State Warriors" ~ "GSW",
  TEAM_NAME == "Milwaukee Bucks" ~ "MIL",
  TEAM_NAME == "Orlando Magic" ~ "ORL",
  TEAM_NAME == "Portland Trail Blazers" ~ "POR",
  TEAM_NAME == "Washington Wizards" ~ "WAS",
  TEAM_NAME == "LA Clippers" ~ "LAC",
  TEAM_NAME == "Charlotte Hornets" ~ "CHA",
  TEAM_NAME == "Chicago Bulls" ~ "CHI",
  TEAM_NAME == "Atlanta Hawks" ~ "ATL",
  TEAM_NAME == "San Antonio Spurs" ~ "SAS",
  TEAM_NAME == "Brooklyn Nets" ~ "BKN",
  TEAM_NAME == "Philadelphia 76ers" ~ "PHI",
  TEAM_NAME == "Indiana Pacers" ~ "IND",
  TEAM_NAME == "Boston Celtics" ~ "BOS",
  TEAM_NAME == "Dallas Mavericks" ~ "DAL",
  TEAM_NAME == "Sacramento Kings" ~ "SAC",
  TEAM_NAME == "Oklahoma City Thunder" ~ "OKC",
  TEAM_NAME == "Los Angeles Lakers" ~ "LAL",
  TEAM_NAME == "Utah Jazz" ~ "UTA",
  TEAM_NAME == "Detroit Pistons" ~ "DET"
)) 

cols_num = c("GAME_ID", "GAME_EVENT_ID", "PLAYER_ID", "TEAM_ID", "PERIOD", "SHOT_DISTANCE", "LOC_X", "LOC_Y", "SHOT_ATTEMPTED_FLAG","SHOT_MADE_FLAG", "MINUTES_REMAINING", "SECONDS_REMAINING")
shots_2025[cols_num] <- sapply(shots_2025[cols_num],as.numeric)


shots_2025 = shots_2025 %>% 
  mutate(OPPOSING_TEAM_NAME = ifelse(TEAM_NAME == HTM, VTM, HTM)) %>% 
  relocate(OPPOSING_TEAM_NAME, .after = TEAM_NAME)

shots_2025 = shots_2025 %>%
  mutate(QUARTER_TIME_LEFT = MINUTES_REMAINING * 60 + SECONDS_REMAINING) %>%
  mutate(GAME_TIME_LEFT = case_when(
    PERIOD <= 4 ~ (4 - PERIOD) * 12 * 60 + MINUTES_REMAINING * 60 + SECONDS_REMAINING,
    PERIOD %in% c(5, 6, 7, 8) ~ MINUTES_REMAINING * 60 + SECONDS_REMAINING
  )) %>% relocate(QUARTER_TIME_LEFT, .after = SECONDS_REMAINING) %>%
  relocate(GAME_TIME_LEFT, .after = QUARTER_TIME_LEFT)

shots_2025 <- shots_2025 %>% 
  mutate(SHOT_ID = row_number()) %>% 
  mutate(SHOT_TYPE = as.factor(SHOT_TYPE)) %>%
  mutate(ACTION_TYPE = as.factor(ACTION_TYPE)) %>% 
  mutate(SHOT_ZONE_BASIC = as.factor(SHOT_ZONE_BASIC)) %>% 
  mutate(SHOT_ZONE_AREA = as.factor(SHOT_ZONE_AREA)) %>% 
  mutate(SHOT_ZONE_RANGE = as.factor(SHOT_ZONE_RANGE)) %>% 
  mutate(POSSIBLE_POINTS = case_when(
    SHOT_TYPE == "2PT Field Goal" ~ 2,
    SHOT_TYPE == "3PT Field Goal" ~ 3
  ))
```

**Building a Logistic Model:**

To build our logistic model, we used the glm function in R. This allowed us to fit a logistic linear model to the data.

After training our model, we used it to estimate the probability that a shot results in a made basket. We made predictions for every field goal attempted in the 2024-25 season. These predictions were made with the help of R's predict function and were loaded into a vector which we added to our main shots dataframe.

```{r}
set.seed(479)

##Train the model on the entire shots df
full_df_fit <- glm(formula = SHOT_MADE_FLAG ~ PERIOD + MINUTES_REMAINING + SECONDS_REMAINING + QUARTER_TIME_LEFT + GAME_TIME_LEFT + ACTION_TYPE + SHOT_TYPE + SHOT_ZONE_RANGE + SHOT_ZONE_AREA + SHOT_ZONE_BASIC + SHOT_DISTANCE + LOC_X + LOC_Y, data = shots_2025, family = binomial("logit"))

##Predictions for the probability that a shot is made
probability_preds <-
   suppressWarnings(predict(object = full_df_fit,
          newdata = shots_2025,
          type = "response"))
```

**Building our Expected Points Model:**

After assigning a probability to every field goal in the dataframe, we are ready to build an expected points model. Our expected points predictions for each shot is simply computed by multiplying the probability (that the shot is made) by the amount of points the shot is worth.

```{r}
##Append probability predictions and compute expected points
shots_2025_xp <- shots_2025 %>% 
  mutate(expected_probability = probability_preds) %>% 
  mutate(EXPECTED_POINTS = expected_probability * POSSIBLE_POINTS)
```

***Formula for Expected Points:***

E\[Xi\] = pi \* Zi

where

-   Xi; i = 1,2,...,n is the amount of points scored from the ith shot

-   pi; i = 1,2,...,n is the probability that the ith shot is made

-   zi; i = 1,2,...,n is the number of points the ith shot is worth

For example, a 2 point field goal attempt with a 50% probability of going in the basket has an expected points of 1.

This is because E\[X\] = 0.5\*2 = 1

**Team Summary Tables:**

After building an expected points model which assigns an expected point value to every field goal from the 2024-25 season, our goal was to compute summary statistics for the expected points scored and allowed for each team.

This was done via a group_by â€“\> summarize command to group shots according to the team the shot-taker was playing for and against. We created two intermediate tables (one for expected points scored and one for expected points allowed) and then merged them into a combined dataframe.

```{r}
##Team Summary Table Expected Points Scored
team_xp_scored <- shots_2025_xp %>%
  group_by(TEAM_NAME) %>% 
  summarize(TOTAL_POINTS = sum(PTS), EXPECTED_TOTAL_POINTS = sum(EXPECTED_POINTS), FGA = sum(SHOT_ATTEMPTED_FLAG), 
            POINTS_PER_100 = (TOTAL_POINTS / FGA)*100, EXPECTED_POINTS_PER_100 = (EXPECTED_TOTAL_POINTS / FGA)*100)

##Team Summary Table Expected Points Allowed
team_xp_allowed <- shots_2025_xp %>%
  group_by(OPPOSING_TEAM_NAME) %>% 
  summarize(TOTAL_POINTS_ALLOWED = sum(PTS), 
            EXPECTED_TOTAL_POINTS_ALLOWED = sum(EXPECTED_POINTS), 
            FG_ALLOWED = sum(SHOT_ATTEMPTED_FLAG), 
            POINTS_ALLOWED_PER_100 = (TOTAL_POINTS_ALLOWED / FG_ALLOWED)*100,
            EXPECTED_POINTS_ALLOWED_PER_100 = (EXPECTED_TOTAL_POINTS_ALLOWED / FG_ALLOWED)*100) %>% 
  rename(TEAM_NAME = OPPOSING_TEAM_NAME)

team_xp_combined <- merge(team_xp_scored, team_xp_allowed, by = "TEAM_NAME") %>% 
  mutate(TOTAL_POINT_DIFF = (TOTAL_POINTS - TOTAL_POINTS_ALLOWED)) %>% 
  mutate(EXPECTED_POINT_DIFF = (EXPECTED_TOTAL_POINTS - EXPECTED_TOTAL_POINTS_ALLOWED))
```

This resulted in a neat summary table. It compares our model's predicted expected total points (scored and allowed) with the actual points scored and allowed by every team in the league.

```{r}
team_xp_combined
```

**Expected Point Differential vs Actual Point Differential:**

To compare our model's predictions for team performance with actual results, we created two charts to contrast our expected point differential predictions with the actual point differentials for each NBA team in the 2024-25 season.

```{r}
##Expected Point Differential vs Actual Point Differential
expected_point_diff <- ggplot(team_xp_combined) + 
  geom_col(aes(x = EXPECTED_POINT_DIFF, y = reorder(TEAM_NAME, EXPECTED_POINT_DIFF)) , fill = "navy") + xlab("Expected Point Differential") + ylab("Team Name") + scale_x_continuous(breaks = seq(-2000, 1500, 250)) + ggtitle("Expected Point Differential by Team") + theme(plot.title = element_text(hjust = 0.5))

actual_point_diff <- ggplot(team_xp_combined) + 
  geom_col(aes(x = TOTAL_POINT_DIFF, y = reorder(TEAM_NAME, TOTAL_POINT_DIFF)), fill = "navy") + xlab("Actual Point Differential") + ylab("Team Name") + scale_x_continuous(breaks = seq(-2000, 1500, 250)) + ggtitle("Actual Point Differential by Team") + theme(plot.title = element_text(hjust = 0.5))

expected_point_diff
```

```{r}
actual_point_diff
```

**Assessing Model Accuracy:**

Lastly, we assess the accuracy of our logistic regression model.

We use log-loss to assess our model's accuracy at predicting probabilities of shots being made. To compute log-loss, we first defined an intermediate function in R. Then, we created 2 training-testing splits (75%/25% training-test split). For each split, we trained the model using the training data and made predictions on the testing data. We then computed log-loss on the training and testing sets and averaged the estimates over the two splits.

```{r}
##Create a function for log loss computation
logloss <- function(y, phat){
  
  if(any(phat < 1e-12)) phat[phat < 1e-12] <- 1e-12
  if(any(phat > 1-1e-12)) phat[phat > 1-1e-12] <- 1-1e-12
  return(-1 * mean( y * log(phat) + (1-y) * log(1-phat)))
}
```

```{r}
##Set number of simulations to 2
n_sims <- 2

##Initialize training and testing log loss vectors
train_logloss <- rep(NA, times = n_sims)
test_logloss <- rep(NA, times = n_sims)

##Set our training df to be 75% of the full df
n_row <- nrow(shots_2025)
n_train <- floor(0.75 * n_row)

##Create 100 training-testing splits. For each split, we train the model using the training df and make predictions on both the training and testing dataframes.
for(r in 1:n_sims){
  set.seed(479+r)
  train_data <-
    shots_2025 |>
    dplyr::slice_sample(n = n_train)
  test_data <-
    shots_2025 |>
    dplyr::anti_join(y = train_data, by = "SHOT_ID") 

  fit <- glm(formula = SHOT_MADE_FLAG ~ PERIOD + MINUTES_REMAINING + SECONDS_REMAINING + QUARTER_TIME_LEFT + GAME_TIME_LEFT + ACTION_TYPE + SHOT_TYPE + SHOT_ZONE_RANGE + SHOT_ZONE_AREA + SHOT_ZONE_BASIC + SHOT_DISTANCE + LOC_X + LOC_Y, data = train_data, family = binomial("logit"))
  
##Here, we are predicting the probability that a shot is made.
  train_preds <-
   suppressWarnings(predict(object = fit,
          newdata = train_data,
          type = "response"))
  
  test_preds <-
   suppressWarnings(predict(object = fit,
           newdata = test_data,
           type = "response"))
  
  train_data$train_probs <- train_preds
  test_data$test_probs <- test_preds
  
##Compute log loss on the training and testing sets and store the values in the training and testing log loss vectors.
  train_logloss[r] <-
    logloss(train_data$SHOT_MADE_FLAG, train_data$train_probs)
  test_logloss[r] <-
    logloss(test_data$SHOT_MADE_FLAG, test_data$test_probs)
}

##Print out the average training and testing log loss over 100 splits.
cat("Dist training logloss:", round(mean(train_logloss), digits = 3), "\n"); cat("Dist testing logloss:", round(mean(test_logloss), digits = 3), "\n")
```

The average log loss for both the training and testing datasets is 0.641.
