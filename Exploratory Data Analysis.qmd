---
title: "test"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("hoopR")
library("dplyr")
library(tictoc)
library(devtools)
library(pacman)
```

```{r}

player_table <-
  hoopR::nba_commonallplayers()[["CommonAllPlayers"]] |>
  dplyr::select(PERSON_ID, DISPLAY_FIRST_LAST) |>
  dplyr::rename(id = PERSON_ID, FullName = DISPLAY_FIRST_LAST) |>
  dplyr::mutate(
    Name = stringi::stri_trans_general(FullName, "Latin-ASCII")) 

player_table |>
  dplyr::filter(id %in% c("201143", "201950", "1627759")) |>
  dplyr::pull(FullName)
```

```{r}
raw_game_log <- hoopR::nba_leaguegamelog(season = 2024)
nba_game_log <- raw_game_log$LeagueGameLog

nba_season_games <- 
  nba_game_log |>
  dplyr::pull(GAME_ID) |>
  unique()
```

```{r}
get_game_stint_data <- function(game_i) {
  
  game_data <- hoopR::nba_pbp(game_id = game_i)
  
  game_data$home_score[1] <- 0
  game_data$away_score[1] <- 0
  game_data$score_margin[1] <- 0
  
  game_data <- 
    game_data |>
    tidyr::fill(home_score, away_score, score_margin)
  
  home_lineups <- 
    game_data |>
    dplyr::select(home_player1, home_player2, home_player3, home_player4, home_player5) |>
    apply(MARGIN = 1, FUN = function(x){paste(sort(x), collapse = "_")})
  away_lineups <-
    game_data |>
    dplyr::select(away_player1, away_player2,away_player3, away_player4, away_player5) |>
    apply(MARGIN = 1, FUN = function(x){paste(sort(x), collapse = "_")})
  
  game_data$home_lineup <- home_lineups
  game_data$away_lineup <- away_lineups
  
  # Now there are a couple of ways to figure out the stints, but I think the
  # best way is to use the substitution events - where a stint changes once
  # a substitution takes places (but only if the previous event was NOT a substitution)
  
  # Start by making an indicator for the stint change:
  game_data <- 
    game_data |>
    dplyr::mutate(is_sub = ifelse(event_type == 8, 1, 0),
                  new_stint_start = ifelse((is_sub == 1) & (dplyr::lead(is_sub) != 1),1, 0))
  
  # For substitutions that take place
  # during a free throw window, then the new stint should start after the free throw
  
  # Easiest way to track if substitution takes places before final free throw:
  game_data <- 
    game_data |>
    dplyr::mutate(sub_during_free_throw = dplyr::case_when(
      (stringr::str_detect(visitor_description, "Free Throw 1 of 1") |
         stringr::str_detect(visitor_description, "Free Throw 2 of 2") |
         stringr::str_detect(visitor_description, "Free Throw 3 of 3")) &
        (dplyr::lag(is_sub) == 1) ~ 1,
      (stringr::str_detect(home_description, "Free Throw 1 of 1") |
         stringr::str_detect(home_description, "Free Throw 2 of 2") |
         stringr::str_detect(home_description, "Free Throw 3 of 3")) &
        (dplyr::lag(is_sub) == 1) ~ 1,
      .default = 0),
      # Now if the sub is followed by this, then set new_stint_start to 0, but
      # if this set a new stint to start post the final free throw:
      new_stint_start = ifelse(is_sub == 1 & dplyr::lead(sub_during_free_throw) == 1, 0, new_stint_start),
      new_stint_start = ifelse(lag(sub_during_free_throw) == 1,1, new_stint_start),
      new_stint_start = ifelse(is.na(new_stint_start), 0, new_stint_start)
    )
  
  # Filter out subs that are not new stints, and then just use
  # the cumulative sum of the new stint start to effectively create a stint ID:
  game_data <- game_data |>
    dplyr::filter(!(is_sub == 1 & new_stint_start == 0)) |>
    dplyr::mutate(stint_id = cumsum(new_stint_start) + 1)
  
  # Toughest part - need to count the number of possessions for each team during
  # the stint... will rely on this for counting when a possession ends:
  # https://squared2020.com/2017/09/18/deep-dive-on-regularized-adjusted-plus-minus-ii-basic-application-to-2017-nba-data-with-r/
  # "Recall that a possession is ended by a converted last free throw, made field goal, defensive rebound, turnover, or end of period"
  
  game_data <- game_data |>
    dplyr::mutate(pos_ends = dplyr::case_when(
      stringr::str_detect(home_description, " PTS") &
        stringr::str_detect(home_description, "Free Throw 1 of 2", negate = TRUE) &
        stringr::str_detect(home_description, "Free Throw 2 of 3",negate = TRUE) ~ 1, # made field goals or free throws
      stringr::str_detect(visitor_description, " PTS") & 
        stringr::str_detect(visitor_description, "Free Throw 1 of 2",negate = TRUE) & 
        stringr::str_detect(visitor_description, "Free Throw 2 of 3",negate = TRUE) ~ 1, 
      stringr::str_detect(tolower(visitor_description), "rebound") &
        stringr::str_detect(tolower(lag(home_description)), "miss ") ~ 1,
      stringr::str_detect(tolower(home_description), "rebound") &
        stringr::str_detect(tolower(lag(visitor_description)), "miss ") ~ 1,
      stringr::str_detect(tolower(home_description), " turnover") ~ 1,
      stringr::str_detect(tolower(visitor_description), " turnover") ~ 1,
      stringr::str_detect(neutral_description, "End") ~ 1,.default = 0))
  
  # Now the final part - compute the stint level summaries:
  game_data |>
    dplyr::group_by(stint_id) |>
    dplyr::summarize(
      home_lineup = dplyr::first(home_lineup),
      away_lineup = dplyr::first(away_lineup),
      n_home_lineups = length(unique(home_lineup)),
      n_away_lineups = length(unique(away_lineup)),
      start_home_score = dplyr::first(home_score),
      end_home_score = dplyr::last(home_score),
      start_away_score = dplyr::first(away_score),
      end_away_score = dplyr::last(away_score),
      start_minutes = dplyr::first(minute_game),
      end_minutes = dplyr::last(minute_game),
      n_pos = sum(pos_ends),
      .groups = "drop") |>
    dplyr::mutate(
      home_points = end_home_score - start_home_score,
      away_points = end_away_score - start_away_score,
      minutes = end_minutes - start_minutes,
      pts_diff = home_points - away_points,
      margin = 100 * (pts_diff) / n_pos,
      game_id = game_i) |>
    dplyr::select(game_id, stint_id, 
                  start_home_score, start_away_score,
                  start_minutes, 
                  end_home_score, end_away_score, end_minutes,
                  home_lineup, away_lineup, n_pos,
                  home_points, away_points, minutes, pts_diff, margin) |>
    dplyr::filter(n_pos != 0)
}

poss_get_game_stints <- 
  purrr::possibly(.f = get_game_stint_data, otherwise = NULL)
```

```{r}
raw_game_log <- hoopR::nba_leaguegamelog(season = 2024)
nba_game_log <- raw_game_log$LeagueGameLog

nba_season_games <- 
  nba_game_log |>
  dplyr::pull(GAME_ID) |>
  unique()


season_stint_data <- 
  purrr::map(nba_season_games, ~poss_get_game_stints(.x)) |>
  dplyr::bind_rows()

game_stint_context <-
  season_stint_data |>
  dplyr::select(
    game_id, stint_id, n_pos,
    start_home_score, start_away_score,start_minutes, 
    end_home_score, end_away_score, end_minutes,
    home_points, away_points, minutes, 
    pts_diff, margin)

home_players_data <-
  season_stint_data |>
  dplyr::select(game_id, stint_id, home_lineup)|>
  tidyr::separate_rows(home_lineup, sep = "_") |>
  dplyr::mutate(on_court = 1) |>
  tidyr::pivot_wider(
    id_cols = c("game_id", "stint_id"),
    names_from = home_lineup,
    values_from = on_court,
    values_fill = 0)
home_players_cols <- colnames(home_players_data)[3:ncol(home_players_data)]

away_players_data <-
  season_stint_data |>
  dplyr::select(game_id, stint_id, away_lineup) |>
  tidyr::separate_rows(away_lineup, sep = "_") |>
  dplyr::mutate(on_court = -1) |>
  tidyr::pivot_wider(
    id_cols = c("game_id", "stint_id"),
    names_from = away_lineup,
    values_from = on_court,
    values_fill = 0)
away_players_cols <- colnames(away_players_data)[3:ncol(away_players_data)]

game_stint_players_data <- 
  home_players_data |>
  dplyr::bind_rows(away_players_data) |>
  dplyr::group_by(game_id, stint_id) |>
  dplyr::summarize(
    dplyr::across(dplyr::everything(), ~ sum(.x, na.rm = TRUE)),
    .groups = "drop")

rapm_data <-
  game_stint_context |>
  dplyr::left_join(game_stint_players_data,by = c("game_id", "stint_id"))
```

```{r}
rapm_data
```

```{r}
hoopR::nba_pbp(game_id = "0022400070", season = 2024)
```

```{r}
hoopR::nba_playerdashptshotdefend()
```

```{r}
# You can install using the pacman package using the following code:
if (!requireNamespace('pacman', quietly = TRUE)){
  install.packages('pacman')
}
```

```{r}
pacman::p_load_current_gh("sportsdataverse/hoopR", dependencies = TRUE, update = TRUE)
```

```{r}
tictoc::tic()
progressr::with_progress({
  nba_pbp <- hoopR::load_nba_pbp()
})
tictoc::toc()
```

```{r}
shots_2025 = data.frame()

for (id in ids_2025){
  cat("Processing player:", id, "\n")  # Track progress
  
  tryCatch({
    player_shots = hoopR::nba_shotchartdetail(player_id = id)$Shot_Chart_Detail
    shots_2025 = rbind(shots_2025, player_shots)
    
    cat("Success! Got", nrow(player_shots), "shots for player", id, "\n")
    
    # Rate limit: wait 2 seconds between requests
    Sys.sleep(2)
    
  }, error = function(e) {
    cat("Error with player", id, ":", e$message, "\n")
    Sys.sleep(2)  # Still wait even on error
  })
}
```

```{r}
#shots_2025 is ONLY REGULAR SEASON
shots_2025 = shots_2025 %>% mutate(PTS = case_when(
  SHOT_MADE_FLAG == 1 & SHOT_TYPE == "3PT Field Goal" ~ 3,
  SHOT_MADE_FLAG == 1 & SHOT_TYPE == "2PT Field Goal" ~ 2,
  TRUE ~ 0
)) %>% relocate(PTS, .after = SHOT_MADE_FLAG)
shots_2025
```

```{r}
shots_players_ids = shots_2025 %>% select(PLAYER_NAME, PLAYER_ID)
shots_players_ids
```

```{r}
nba_pbp # PLAYOFFS AND REGULAR SEASON
```

```{r}
nba_pbp = nba_pbp %>% mutate(
  player_name =
)
```

```{r}
nba_players_with_ids = left_join(shots_players_ids, nba_pbp, by = "")
```

```{r}
nba_shots_unclean = nba_pbp %>% dplyr::filter(shooting_play == TRUE)
```

```{r}
nba_shots = nba_shots_unclean %>% filter(!grepl("Free Throw", type_text))
nba_shots
```

```{r}
play_in = nba_shots %>% filter(season_type == 5) 
playoffs = nba_shots %>% filter(season_type == 3)
regular_season = nba_shots %>% filter(season_type == 2)
regular_season
```

```{r}
table(nba_shots$type_text)
```

```{r}
kawhi = hoopR::nba_shotchartdetail(player_id = "202691")$Shot_Chart_Detail
kawhi
```

```{r}
hoopR::nba_leaguedashplayershotlocations() # Summary shot data for every player
```

```{r}
hoopR::nba_playerdashptshots(player_id = "1630639")  ## Gives a bunch of summary tables about shot info with player_id as input
```

```{r}
idss = as.data.frame(nba_commonallplayers())
players_2025 = idss %>% filter(CommonAllPlayers.TO_YEAR == 2025)
ids_2025 = players_2025$CommonAllPlayers.PERSON_ID
```

```{r}
max(shots_2025$GAME_DATE)
```

```{r}
par(mar = c(3,3,2,1), mgp = c(1.8, 0.5, 0))
plot(nba_shots$coordinate_x, nba_shots$coordinate_y, 
     xlab = "coordinate_x", ylab = "coordinate_y",
     pch = 16, cex = 0.2, col = rgb(0,0,0, 0.1))
```

```{r}
save(shots_2025,file="shots_2025.Rda")
```

```{r}
library(ggplot2)

ggplot(nba_shots, aes(x = coordinate_x, y = coordinate_y)) +
  stat_density_2d_filled(alpha = 0.8, bins = 30) +
  scale_fill_viridis_d() +
  labs(title = "NBA Shot Frequency Heatmap",
       x = "Court X Coordinate", 
       y = "Court Y Coordinate") +
  theme_minimal()
```
